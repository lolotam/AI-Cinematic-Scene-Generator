import { GoogleGenAI, Modality } from "@google/genai";
import type { ImageFile } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable is not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export const enhancePrompt = async (userPrompt: string): Promise<string> => {
  if (!userPrompt.trim()) {
    return Promise.resolve("");
  }
  try {
    const systemInstruction = `You are an expert cinematographer and prompt engineer for an AI image generator. Your task is to take a user's simple scene description and rewrite it into a single, cohesive paragraph that is vivid, detailed, and cinematic.

Focus on expanding these elements:
- **Lighting:** Be specific (e.g., "dappled sunlight filtering through a dense canopy," "harsh fluorescent glow of a sterile hallway," "soft, warm glow of a fireplace casting long shadows").
- **Camera Work:** Suggest angles, shots, and focus (e.g., "a dramatic low-angle shot," "a shallow depth of field focusing on the character's eyes," "a sweeping wide shot revealing the vast landscape").
- **Atmosphere & Mood:** Evoke a feeling (e.g., "a tense, claustrophobic atmosphere," "a serene and tranquil mood," "a chaotic and energetic vibe").
- **Composition:** Describe the arrangement of elements in the scene.
- **Visual Details:** Add specific, tangible details that bring the scene to life.

Do NOT change the core subject, characters, or action of the original prompt. Just embellish it with cinematic detail.
Return ONLY the rewritten prompt as a single paragraph of text, without any preamble, titles, or quotation marks.`;

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: `Rewrite this scene description: "${userPrompt}"`,
        config: {
            systemInstruction: systemInstruction,
        }
    });

    return response.text.trim();
  } catch (error) {
    console.error("Error enhancing prompt with Gemini API:", error);
    if (error instanceof Error) {
        return Promise.reject(new Error(`Failed to enhance prompt: ${error.message}`));
    }
    return Promise.reject(new Error("An unknown error occurred during prompt enhancement."));
  }
};

interface GenerateImageParams {
  prompt: string;
  characterImages: ImageFile[];
  styleImage: ImageFile | null;
  baseImage?: ImageFile | null;
  maskImage?: ImageFile | null;
}

export const generateStoryImage = async ({
  prompt,
  characterImages,
  styleImage,
  baseImage,
  maskImage,
}: GenerateImageParams): Promise<string> => {
  try {
    const parts: any[] = [];

    // Order for editing: base image, then mask (if available), then other images, then prompt
    if (baseImage) {
        parts.push({
            inlineData: {
                data: baseImage.base64,
                mimeType: baseImage.mimeType,
            },
        });
    }

    if (maskImage) {
        parts.push({
            inlineData: {
                data: maskImage.base64,
                mimeType: maskImage.mimeType,
            },
        });
    }

    characterImages.forEach(charImg => {
      parts.push({
        inlineData: {
          data: charImg.base64,
          mimeType: charImg.mimeType,
        },
      });
    });

    if (styleImage) {
      parts.push({
        inlineData: {
          data: styleImage.base64,
          mimeType: styleImage.mimeType,
        },
      });
    }

    parts.push({ text: prompt });

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image-preview',
      contents: { parts },
      config: {
        responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
    });
    
    const candidate = response.candidates?.[0];

    if (!candidate || !candidate.content || !candidate.content.parts) {
      let errorMessage = "The model did not return any content.";
      if (candidate?.finishReason && candidate.finishReason !== 'STOP') {
        errorMessage += ` Reason: ${candidate.finishReason}.`;
      }
      if (candidate?.safetyRatings?.some(r => r.blocked)) {
        const blockedCategories = candidate.safetyRatings
          .filter(r => r.blocked)
          .map(r => r.category.replace('HARM_CATEGORY_', ''))
          .join(', ');
        errorMessage += ` The request was blocked for safety reasons (${blockedCategories}). Please adjust your prompt.`;
      }
      throw new Error(errorMessage);
    }

    // Find the first image part in the response
    for (const part of candidate.content.parts) {
      if (part.inlineData) {
        const base64ImageBytes: string = part.inlineData.data;
        return `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
      }
    }

    throw new Error("No image was generated by the model, although a response was received.");

  } catch (error) {
    console.error("Error generating image with Gemini API:", error);
    if (error instanceof Error) {
        return Promise.reject(new Error(`Failed to generate image: ${error.message}`));
    }
    return Promise.reject(new Error("An unknown error occurred during image generation."));
  }
};